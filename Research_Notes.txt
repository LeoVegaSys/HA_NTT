Hi-Avail

https://dev.mysql.com/doc/refman/5.7/en/replication-howto.html
https://medium.com/@tushar.jadhav29/how-to-setup-mysql-master-master-replication-ebfb7348de8f
https://hevodata.com/learn/mysql-master-master-replication/

Performance benchmarking for binlog vs binlogless slave order preservation : https://dev.mysql.com/blog-archive/preserve-commit-order-on-binlogless-replicas/
    - Implementing binlogless replication in MySQL involves disabling the binary log and ensuring that transactions are committed in the same order they are replicated. This feature was introduced in MySQL 8.0.19 and allows asynchronous replicas to operate without the binary log enabled, while still preserving the commit order of transactions.

1. Source & replica/s should have server ID between 1 and 2^32 - 1
2. Binary logging should be enabled on source and replica/s, using log-bin option in  my.cnf or my.ini file, within the [mysqld] section

[mysqld]
log-bin=mysql-bin
server-id=1

3.For the greatest possible durability and consistency in a replication setup using InnoDB with transactions, you should use innodb_flush_log_at_trx_commit=1 and sync_binlog=1 in the source's my.cnf file.

4. Ensure that the skip_networking and bind_address system variables are not enabled on your source. If networking has been disabled, the replica cannot communicate with the source and replication fails. For preserving the commit order on MASTER and SLAVE, ensure that slave-preserve-commit-order is enabled (ON). This option can only enforce commit order if the SLAVE has the binary log turned on (log_bin=binlog) and applier threads are logging to its own binary log (log_slave_updates=ON)

5. Each replica connects to the source using a MySQL user name and password, so there must be a user account on the source that the replica can use to connect. Any account can be used for this operation, providing it has been granted the REPLICATION SLAVE privilege. Following this, itâ€™s good practice to run the FLUSH PRIVILEGES command. This will free up any memory that the server cached as a result of the preceding CREATE USER and GRANT statements.

    mysql> CREATE USER 'repl'@'%.example.com' IDENTIFIED BY 'password';
    mysql> GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%.example.com';
    mysql> FLUSH PRIVILEGES;

6. Gather source server details, to start the replication process
    i.Start a session on the source by connecting to it with the command-line client, and flush all tables and block write statements
        mysql> FLUSH TABLES WITH READ LOCK
    ii. Determine the current binary log file name and position from the master status
        mysql> SHOW MASTER STATUS

7. If you have existing data that needs be to synchronized with the replica before you start replication, leave the client running so that the lock remains in place. This prevents any further changes being made, so that the data copied to the replica is in synchrony with the source.

8. Read lock can be released either by ending the client session, or running the command UNLOCK TABLES

9. Replica setup:
    i. Each replica must have a unique non-zero server ID.
    ii. Start up the replica, ensuring that replication does not start by using the --skip-slave-start option, and connect to it.
    iii. To set up the replica to communicate with the source for replication, configure the replica with the necessary connection information
        mysql> CHANGE MASTER TO
            ->     MASTER_HOST='source_host_name',
            ->     MASTER_USER='replication_user_name',
            ->     MASTER_PASSWORD='replication_password',
            ->     MASTER_LOG_FILE='recorded_log_file_name',
            ->     MASTER_LOG_POS=recorded_log_position;
    iv. Start the replication threads:
        mysql> START SLAVE

10. Adding additional replicas :
    i. Stop the existing replica
        mysql> STOP SLAVE;
    ii. Record the replica status information, particularly the source's binary log file and relay log file positions.
        mysql> SHOW SLAVE STATUS
    iii. Shut down the existing replica:
        $> mysqladmin shutdown
    iv. Copy the data directory from the existing replica to the new replica, including the log files and relay log files. You can do this by creating an archive using tar or WinZip, or by performing a direct copy using a tool such as cp or rsync.
    v. After copying, delete the auto.cnf file from the copy of the data directory on the new replica, so that the new replica is started with a different generated server UUID. The server UUID must be unique.
    vi. When copying is complete, restart the existing replica.
    vii. On the new replica, edit the configuration and give the new replica a unique non-zero server ID.
    viii. Start the new replica server, specifying the --skip-slave-start option so that replication does not start yet. 
    ix. Issue SHOW SLAVE STATUS to confirm that the new replica has the correct settings when compared with the existing replica.
    x. Start the replication threads by issuing a START SLAVE statement

11. If slave is not able to connect to master for replication, 
    i.Check mysql connection from slave to master from command line, using -h option to specify hostname.
    ii. Check if firewall is enabled for the servers, and disable if enabled
        systemctl status/stop firewalld